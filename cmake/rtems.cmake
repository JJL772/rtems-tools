# ----------------------------------------------------------------------------
# Company    : SLAC National Accelerator Laboratory
# ----------------------------------------------------------------------------
# Description : CMake utilities for RTEMS
# ----------------------------------------------------------------------------
# This file is part of the rtems-tools package. It is subject to
# the license terms in the LICENSE.txt file found in the top-level directory
# of this distribution and at:
#    https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
# No part of the rtems-tools package, including this file, may be
# copied, modified, propagated, or distributed except according to the terms
# contained in the LICENSE.txt file.
# ----------------------------------------------------------------------------

# Defines the following functions:
#  rtems_add_executable
#  rtems_add_object
#  rtems_check_include
#  rtems_check_lib

include(GNUInstallDirs)

set(CMAKE_VERBOSE_MAKEFILE ON)

# Helper command to add a simple executable for RTEMS
# Handles linking of critical components and incorporation of 
function(rtems_add_simple_executable TARGET)
    add_executable(
        ${TARGET} ${ARGN}
    )

    # Set linker flags
    separate_arguments(RTEMS_EXE_LDFLAGS)
    target_link_options(
        ${TARGET} PRIVATE ${RTEMS_EXE_LDFLAGS}
    )
endfunction()

# Helper command to add an ELF executable and generate a bootable image from it
function(rtems_add_executable TARGET)
    # A quick rundown on what's happening here:
    #
    #  ${TARGET}
    #    First, ${TARGET} is generated. This is a standard ELF executable linked with the relevant RTEMS
    #    flags. This is the "stage 1" binary. This should generally not be used for anything (other than
    #    the other stages listed here)
    # 
    #  ${TARGET}.obj
    #    Next, a loadable symbols object is generated off of ${TARGET}. This is meant to be used with the
    #    RTEMS dynamic linker, as it needs an ELF file without program headers or anything like that.
    #
    #  ${TARGET}-intr.o
    #    An object file generated by rtems-syms that includes the embedded symbol table. Linked into stage 2
    #
    #  ${TARGET}.exe
    #    The "stage 2" binary. This uses the same link command as the stage 1 binary, except that it also
    #    includes ${TARGET}-intr.o and the accompanying embedded symbol table. The runtime linker (RTL) will
    #    use the embedded symbol table to resolve symbols in object files loaded later on.
    #    This ELF binary can be used with QEMU.
    #
    #  ${TARGET}.boot
    #    This is the actual bootable image. It's just a flat binary generated off of the stage 2 .exe 
    # 
    # NOTE: The above is only relevant for RTEMS 6. RTEMS 4.X w/cexpsh and GeSys behaves similarly,
    #  but uses different tools to accomplish the task. Those tools are not supported here.

    # Generate list of forced symbol refs
    add_custom_command(
        OUTPUT "${CMAKE_BINARY_DIR}/${TARGET}-extra-syms.c"
        COMMAND "${CMAKE_CURRENT_FUNCTION_LIST_DIR}/../mksyms.py"
            -o "${CMAKE_BINARY_DIR}/${TARGET}-extra-syms.c"
            -a "${RTEMS_ARCH}"
            -c "${CMAKE_CURRENT_FUNCTION_LIST_DIR}/../sym/base-symbols.toml"
        COMMENT "Generating additional symbol refs"
        DEPENDS "${CMAKE_CURRENT_FUNCTION_LIST_DIR}/../sym/base-symbols.toml"
    )

    # Generate base executable that will be used to feed rtems-syms
    add_executable(
        ${TARGET} "${CMAKE_BINARY_DIR}/${TARGET}-extra-syms.c" ${ARGN}
    )

    # Set linker flags
    separate_arguments(RTEMS_EXE_LDFLAGS)
    target_link_options(
        ${TARGET} PRIVATE ${RTEMS_EXE_LDFLAGS}
    )

    # Legacy CEXP path. Uses rtems-xsyms to generate a symbol list for use with Cexpsh.
    if (USE_CEXP)
        # Generate a symbols list off of the existing binary
        add_custom_command(
            OUTPUT "${CMAKE_BINARY_DIR}/${TARGET}-intr.c"
            COMMAND "${CMAKE_RTEMS_XSYMS}" -C
                "${CMAKE_BINARY_DIR}/${TARGET}"
                "${CMAKE_BINARY_DIR}/${TARGET}-intr.c"
            DEPENDS "${TARGET}"
            COMMENT "Generating symbols list with rtems-xsyms"
        )

        # Generate the stage 2 exe with embedded symbol table
        add_executable(
            "${TARGET}-exe" $<TARGET_OBJECTS:${TARGET}> "${CMAKE_BINARY_DIR}/${TARGET}-intr.c"
        )

    else()
        # RTEMS RTL path. Uses rtems-syms to generate and embed a list of symbols

        # Generate a loadable symbols object
        add_custom_command(
            OUTPUT "${CMAKE_BINARY_DIR}/${TARGET}.obj"
            COMMAND "${CMAKE_RTEMS_SYMS}" -C "${CMAKE_C_COMPILER}" -c "${CMAKE_C_FLAGS}" -o "${TARGET}.obj" "${CMAKE_BINARY_DIR}/${TARGET}"
            DEPENDS "${TARGET}"
            COMMENT "Generating loadable symbols"
        )

        # Gather symbols off of the executable
        add_custom_command(
            OUTPUT "${CMAKE_BINARY_DIR}/${TARGET}-intr.o"
            COMMAND "${CMAKE_RTEMS_SYMS}" -e -C "${CMAKE_C_COMPILER}" -c "${CMAKE_C_FLAGS}"
                -m "${CMAKE_BINARY_DIR}/${TARGET}.map" -o "${CMAKE_BINARY_DIR}/${TARGET}-intr.o" "${CMAKE_BINARY_DIR}/${TARGET}"
            DEPENDS "${TARGET}"
            COMMENT "Generating list of embedded symbols"
        )

        # Generate a stage 2 exe with embedded symbol table
        add_executable(
            ${TARGET}-exe $<TARGET_OBJECTS:${TARGET}> "${CMAKE_BINARY_DIR}/${TARGET}-intr.o"
        )
    endif()

    # Link against the same libraries as stage 1 executable
    target_link_libraries(
        ${TARGET}-exe $<TARGET_PROPERTY:${TARGET},LINK_LIBRARIES>
    )

    set_target_properties(
        ${TARGET}-exe PROPERTIES
            LINKER_LANGUAGE C
            OUTPUT_NAME ${TARGET}.exe
    )

    # Set the same linker flags
    separate_arguments(RTEMS_EXE_LDFLAGS)
    target_link_options(
        ${TARGET}-exe PRIVATE ${RTEMS_EXE_LDFLAGS}
    )

    # Generate a flat binary file that can be directly booted
    add_custom_command(
        OUTPUT "${CMAKE_BINARY_DIR}/${TARGET}.boot"
        COMMAND "${CMAKE_OBJCOPY}" -O binary "${TARGET}.exe" "${TARGET}.boot"
        DEPENDS "${TARGET}-exe"
        COMMENT "Generating bootable image ${TARGET}.boot"
    )

    add_custom_target(
        "${TARGET}-boot" ALL
        DEPENDS "${CMAKE_BINARY_DIR}/${TARGET}.boot"
    )

    #add_custom_target(
    #    "${TARGET}-obj" ALL
    #    DEPENDS "${CMAKE_BINARY_DIR}/${TARGET}.obj"
    #)

    # Install to an EPICS-style "shared" prefix
    if (SHARED_PREFIX)
        install(
            TARGETS "${TARGET}"

            RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}/RTEMS-${RTEMS_BSP}"
            LIBRARY DESTINATION "${CMAKE_INSTALL_LIBDIR}/RTEMS-${RTEMS_BSP}"
            ARCHIVE DESTINATION "${CMAKE_INSTALL_LIBDIR}/RTEMS-${RTEMS_BSP}"
            PUBLIC_HEADER DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}/RTEMS-${RTEMS_BSP}"
        )
        install(
            FILES "${CMAKE_BINARY_DIR}/${TARGET}.boot" "${CMAKE_BINARY_DIR}/${TARGET}.exe"
            DESTINATION "${CMAKE_INSTALL_BINDIR}/RTEMS-${RTEMS_BSP}"
        )
    else()
        install(
            FILES "${CMAKE_BINARY_DIR}/${TARGET}.boot" "${CMAKE_BINARY_DIR}/${TARGET}.exe"
            DESTINATION "${CMAKE_INSTALL_BINDIR}"
        )
    endif()
endfunction()

# Add a new object
# Parameters:
#  TARGET       - Name of the target to add
#  BASE_TARGET  - Name of the base executable
function(rtems_add_object TARGET BASE_TARGET)

    add_library(
        ${TARGET} OBJECT
        ${ARGN}
    )

    # Generate a normal ELF file that can be used with either Cexp or RTL loaders
    add_executable(
        ${TARGET}-elf ${ARGN}
    )

    # Set module linker flags
    separate_arguments(RTEMS_MODULE_LDFLAGS)
    target_link_options(
        ${TARGET}-elf PRIVATE "${RTEMS_MODULE_LDFLAGS}"
    )

    # Tweak the name to a <TARGET>.obj
    set_target_properties(
        ${TARGET}-elf
        PROPERTIES
            LIBRARY_OUTPUT_NAME "${TARGET}"
            RUNTIME_OUTPUT_NAME "${TARGET}"
            SUFFIX ".obj"
            PREFIX ""
    )

    add_custom_command(
        OUTPUT "${CMAKE_BINARY_DIR}/${TARGET}.rap"
        COMMAND "${CMAKE_RTEMS_LD}"
            -O elf -e rtemsEntryPoint
            -b "${CMAKE_BINARY_DIR}/${BASE_TARGET}.exe"
            -L "${RTEMS_BSP_DIR}/lib"
            -r "${RTEMS_TOP}/target/rtems"
            -C "${CMAKE_C_COMPILER}"
            -L "${CMAKE_BINARY_DIR}"
            -o "${CMAKE_BINARY_DIR}/${TARGET}.rap"
            $<TARGET_OBJECTS:${TARGET}>
            -lrtemsbsp -lrtemscpu
        DEPENDS "${TARGET}" "${CMAKE_BINARY_DIR}/${BASE_TARGET}.exe"
        COMMAND_EXPAND_LISTS
    )

    add_custom_target(
        "${TARGET}-obj" ALL
        DEPENDS "${CMAKE_BINARY_DIR}/${TARGET}.rap"
    )

    # Install the resutling loadable RTL object
    install(
        FILES "${CMAKE_BINARY_DIR}/${TARGET}.rap"
        DESTINATION "${CMAKE_INSTALL_BINDIR}"
    )

    # Install the loadable ELF
    install(
        FILES "${CMAKE_BINARY_DIR}/${TARGET}.obj"
        DESTINATION "${CMAKE_INSTALL_BINDIR}"
    )

endfunction()

# Helper function to incorporate additional libraries into the specified executable
# Parameters:
#   TARGET  : Name of the target
#   LIBS    : List of libraries to get symbols from
#   LIBDIRS : List of library search directories
function(rtems_include_libs)
    # Parse the args
    cmake_parse_arguments(
        arg
        "LDEP"
        "TARGET"
        "LIBS;LIBDIRS"
        ${ARGN}
    )

    list(TRANSFORM arg_LIBS PREPEND "-l")
    list(TRANSFORM arg_LIBDIRS PREPEND "-L")

    if (NOT arg_LDEP)
        # Generate a list of symbol refs
        add_custom_command(
            OUTPUT "${CMAKE_BINARY_DIR}/${arg_TARGET}-inc-syms.lds"
            COMMAND "${CMAKE_CURRENT_FUNCTION_LIST_DIR}/../mksyms.py"
                -o "${CMAKE_BINARY_DIR}/${arg_TARGET}-inc-syms.lds"
                -C "${RTEMS_ARCH}-rtems${RTEMS_TOOL_VERSION}"
                -N "__symbolRefIncLibs"
                -T "linker"
                -L "${RTEMS_BSP_DIR}/lib"
                -L "${CMAKE_BINARY_DIR}"
                -a "${RTEMS_ARCH}"
                -c "${CMAKE_CURRENT_FUNCTION_LIST_DIR}/../sym/base-symbols.toml"
                ${arg_LIBDIRS}
                ${arg_LIBS}
            COMMENT "Generating additional symbol refs for included libraries"
            COMMAND_EXPAND_LISTS
            DEPENDS "${CMAKE_CURRENT_FUNCTION_LIST_DIR}/../sym/base-symbols.toml"
                    "${CMAKE_CURRENT_FUNCTION_LIST_DIR}/../mksyms.py"
        )

        add_custom_target(
            "${arg_TARGET}-inc-syms-lds"
            DEPENDS "${CMAKE_BINARY_DIR}/${arg_TARGET}-inc-syms.lds"
        )

        add_dependencies(
            "${arg_TARGET}" "${arg_TARGET}-inc-syms-lds"
        )

        # Add the sources to the target. These must be added to the 1st stage target
        # so that xsyms (or rtems-ld) can generate a symbol table including them.
        #target_sources(
        #    "${arg_TARGET}" PRIVATE
        #    "${CMAKE_BINARY_DIR}/${arg_TARGET}-inc-syms.c"
        #)
        
        # Force linker to emit symbols
        #set_target_properties(
        #    "${arg_TARGET}" "${arg_TARGET}-exe" PROPERTIES 
        #        LINK_FLAGS "-Wl,-u __symbolRefIncLibs"
        #)

        target_link_options(
            "${arg_TARGET}" PRIVATE
            "-Wl,-T${CMAKE_BINARY_DIR}/${arg_TARGET}-inc-syms.lds"
        )

        target_link_options(
            "${arg_TARGET}-exe" PRIVATE
            "-Wl,-T${CMAKE_BINARY_DIR}/${arg_TARGET}-inc-syms.lds"
        )
    else()
        # Generate using ldep
        add_custom_command(
            OUTPUT "${CMAKE_BINARY_DIR}/${arg_TARGET}.lds" "${CMAKE_BINARY_DIR}/${arg_TARGET}-inc-syms.c"
            COMMAND "${CMAKE_CURRENT_FUNCTION_LIST_DIR}/../ldep.py"
                -c "${CMAKE_BINARY_DIR}/${arg_TARGET}-inc-syms.c"
                -e "${CMAKE_BINARY_DIR}/${arg_TARGET}.lds"
                -C "${RTEMS_ARCH}-rtems${RTEMS_TOOL_VERSION}"
                -O "${CMAKE_BINARY_DIR}"
                -L "${RTEMS_BSP_DIR}/lib"
                -L "${CMAKE_BINARY_DIR}"
                ${arg_LIBDIRS}
                ${arg_LIBS}
            COMMENT "Generating additional symbol refs using ldep"
            COMMAND_EXPAND_LISTS
        )

        # Add the sources to the target. These must be added to the 1st stage target
        # so that xsyms (or rtems-ld) can generate a symbol table including them.
        target_sources(
            "${arg_TARGET}" PRIVATE
            "${CMAKE_BINARY_DIR}/${arg_TARGET}-inc-syms.c"
        )

        target_link_options(
            "${arg_TARGET}" PRIVATE
            "-Wl,-T${CMAKE_BINARY_DIR}/${arg_TARGET}.lds"
        )

        target_link_options(
            "${arg_TARGET}-exe" PRIVATE
            "-Wl,-T${CMAKE_BINARY_DIR}/${arg_TARGET}.lds"
        )
    endif()
endfunction()

# Helper function to add and generate a rootfs.
# This will automatically add the rootfs.c file to your target. call rootfs_unpack() to unpack at runtime
# Parameters:
#   TARGET  : Name of the target
#   DIR     : Directory of the rootfs, must contain a rootfs.txt
#   TYPE    : rootfs type, either tar or builtin
function(rtems_add_rootfs TARGET DIR TYPE)
    enable_language(ASM)

    # Generate list of files we'll depend on
    file(GLOB_RECURSE ROOTFS_FILES "${DIR}/**")

    set(ROOTFS_ARGS "")
    if ("${TYPE}" STREQUAL "tar" OR "${TYPE}" STREQUAL "TAR")
        set(ROOTFS_ARGS "-t")
    endif()

    add_custom_command(
        OUTPUT "${CMAKE_BINARY_DIR}/${TARGET}-rootfs.S"
        COMMAND "${CMAKE_CURRENT_FUNCTION_LIST_DIR}/../mkrootfs.py" "${ROOTFS_ARGS}"
            -o "${CMAKE_BINARY_DIR}/${TARGET}-rootfs.S" -i "${DIR}"
            -m "BSP_LIBS=${RTEMS_TOP}/target/rtems/${RTEMS_ARCH}-rtems${RTEMS_TOOL_VERSION}/${RTEMS_BSP}/lib"
            -m "TOOLCHAIN_LIBS=${RTEMS_TOP}/host/linux-x86_64/${RTEMS_ARCH}-rtems${RTEMS_TOOL_VERSION}/lib"
        DEPENDS ${ROOTFS_FILES}
    )
    
    # Add rootfs sources to target
    target_sources(
        ${TARGET} PRIVATE "${CMAKE_BINARY_DIR}/${TARGET}-rootfs.S"
    )
endfunction()

# Compiles a dtb file and includes it into the target.
# Summary of args:
#  - TARGET: String; Name of the target
#  - FILE: String; Path to the DTS file
function(rtems_add_dts TARGET FILE)
    get_filename_component(DTS_FILE "${FILE}" ABSOLUTE)

    add_custom_command(
        OUTPUT "${CMAKE_BINARY_DIR}/${TARGET}-fdt.dtb"
        COMMAND "${CMAKE_DTC}" -@ -I dts -O dtb -o "${CMAKE_BINARY_DIR}/${TARGET}-fdt.dtb" "${DTS_FILE}"
    )

    add_custom_command(
        DEPENDS "${CMAKE_BINARY_DIR}/${TARGET}-fdt.dtb"
        COMMAND "${CMAKE_CURRENT_FUNCTION_LIST_DIR}/../bin2as.py"
            -i "${CMAKE_BINARY_DIR}/${TARGET}-fdt.dtb"
            -o "${CMAKE_BINARY_DIR}/${TARGET}-fdt.S"
            -v "system_dtb"
        OUTPUT "${CMAKE_BINARY_DIR}/${TARGET}-fdt.S"
    )

    target_sources(
        ${TARGET} PRIVATE "${CMAKE_BINARY_DIR}/${TARGET}-fdt.S"
    )
endfunction()

# Check for a library. Similar to check_library_exists, but uses a more direct method of searching for symbols.
# Performing an actual binary compilation can be tricky with RTEMS, and often fails due to the interdependence of
# libraries. Using nm to directly check for defined symbols works much more reliably
# Summary of args:
#  LIB        - Name of the library
#  FUNC       - Function to check for in the library
#  VARIABLE   - Variable to set
function(rtems_check_lib LIB FUNC VARIABLE)
    execute_process(
        COMMAND "${CMAKE_CURRENT_FUNCTION_LIST_DIR}/../findlibs.py"
                "--cmake"
                -C "${RTEMS_ARCH}-rtems${RTEMS_TOOL_VERSION}-gcc"
                ${CMAKE_C_FLAGS}
                ${RTEMS_LDFLAGS}
                "--check-sym" "${FUNC}"
                "-l${LIB}"
        RESULT_VARIABLE CHECK_RESULT
    )

    if (${CHECK_RESULT} EQUAL 0)
        set(${VARIABLE} 1 PARENT_SCOPE)
        message(STATUS "Found ${FUNC} in ${LIB}")
    else()
        set(${VARIABLE} 0 PARENT_SCOPE)
        message(STATUS "Could NOT find ${FUNC} in ${LIB}")
    endif()
endfunction()

# Check for an include. Similar to check_include_file, but sets CMAKE_REQUIRED_FLAGS so it works right.
# Summary of args:
#  INCLUDE    - Include file to check for
#  VARIABLE   - Variable to set
function(rtems_check_include INCLUDE VARIABLE)
    include(CheckIncludeFile)
    
    set(CMAKE_REQUIRED_FLAGS "${CMAKE_C_FLAGS} ${RTEMS_LDFLAGS} -lrtemsdefaultconfig")
    check_include_file("${INCLUDE}" ${VARIABLE})
    if (${VARIABLE})
        set(${VARIABLE} 1 PARENT_SCOPE)
    else()
        set(${VARIABLE} 0 PARENT_SCOPE)
    endif()
endfunction()

# Configure various RTEMS C flags, determine available packages, etc.
# Summary of set variables:
#  - RTEMS_NETWORKING_STACK: String; Either BSD, LEGACY, LWIP or NONE depending on the network stack
#  - HAVE_LIBDEBUGGER: BOOL; Set if we have -ldebugger for this target
#  - RTEMS_BSD_STACK: BOOL; Set if we have the BSD stack
#  - RTEMS_LEGACY_STACK: BOOL; Set if we have the legacy stack
#  - RTEMS_LWIP_STACK: BOOL; Set if we have the LwIP stack
function(rtems_cmake_init)
    include(CheckIncludeFile)
    include(CheckLibraryExists)

    #set(CMAKE_REQUIRED_FLAGS "${CMAKE_C_FLAGS} ${RTEMS_LDFLAGS} -lrtemsdefaultconfig")
    rtems_check_include("rtems/bsd/bsd.h" HAVE_RTEMS_BSD_BSD_H)
    rtems_check_include("rtems/rtems_bsdnet_internal.h" HAVE_RTEMS_RTEMS_BSDNET_INTERNAL_H)
    rtems_check_include("lwip.h" HAVE_LWIP_H)

    if (HAVE_RTEMS_BSD_BSD_H)
        set(RTEMS_NETWORKING_STACK "BSD" PARENT_SCOPE)
        set(RTEMS_BSD_STACK 1 PARENT_SCOPE)
        set(MISC_CFLAGS "${MISC_CFLAGS} -DRTEMS_BSD_STACK=1")
        message(STATUS "Found RTEMS BSD Networking")
    elseif(HAVE_RTEMS_RTEMS_BSDNET_INTERNAL_H)
        set(RTEMS_NETWORKING_STACK "LEGACY" PARENT_SCOPE)
        set(RTEMS_LEGACY_STACK 1 PARENT_SCOPE)
        set(MISC_CFLAGS "${MISC_CFLAGS} -DRTEMS_LEGACY_STACK=1")
        message(STATUS "Found RTEMS Legacy Networking")
    elseif(HAVE_LWIP_H)
        set(RTEMS_NETWORKING_STACK "LWIP" PARENT_SCOPE)
        set(RTEMS_LWIP_STACK 1 PARENT_SCOPE)
        set(MISC_CFLAGS "${MISC_CFLAGS} -DRTEMS_LWIP_STACK=1")
        message(STATUS "Found RTEMS LwIP Networking")
    else()
        set(RTEMS_NETWORKING_STACK "NONE" PARENT_SCOPE)
        message(STATUS "No networking")
    endif()

    # Check for libdebugger
    rtems_check_lib(debugger rtems_debugger_start HAVE_LIBDEBUGGER)
    set(HAVE_LIBDEBUGGER ${HAVE_LIBDEBUGGER} PARENT_SCOPE)

    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${MISC_CFLAGS}" PARENT_SCOPE)
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${MISC_CFLAGS}" PARENT_SCOPE)
endfunction()
