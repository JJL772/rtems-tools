# Additional tools for RTEMS

# A quick rundown on what's happening here:
#
#  ${TARGET}
#    First, ${TARGET} is generated. This is a standard ELF executable linked with the relevant RTEMS
#    flags. This is the "stage 1" binary.
# 
#  ${TARGET}.obj
#    Next, a loadable symbols object is generated off of ${TARGET}. This is meant to be used with the
#    RTEMS dynamic linker, as it needs an ELF file without program headers or anything like that.
#
#  ${TARGET}-intr.o
#    An object file generated by rtems-syms that includes the embedded symbol table. Used with stage 2
#
#  ${TARGET}.exe
#    This is the "stage 2 binary". It's the same as the stage 1 binary, except that it includes ${TARGET}-intr.o
#    Essentially, this is just the stage 1 binary, but with a special embedded symbol table that the RTL can
#    lookup at runtime. This is required because bootable images are flat binaries and thus cannot have
#    ELF symbol tables in them. The same requirement does not exist for loadable objects.

include(GNUInstallDirs)

# Helper command to add an ELF executable and generate a bootable image from it
function(rtems_add_executable TARGET)

    # Generate base executable that will be used to feed rtems-syms
    add_executable(
        ${TARGET} ${ARGN}
    )

    # Generate a loadable symbols object
    add_custom_command(
        OUTPUT "${CMAKE_BINARY_DIR}/${TARGET}.obj"
        COMMAND "${CMAKE_RTEMS_SYMS}" -C "${CMAKE_C_COMPILER}" -c "${CMAKE_C_FLAGS}" -o "${TARGET}.obj" "${TARGET}"
        DEPENDS "${CMAKE_BINARY_DIR}/${TARGET}"
        COMMENT "Generating loadable symbols"
    )

    # Gather symbols off of the executable
    add_custom_command(
        OUTPUT "${CMAKE_BINARY_DIR}/${TARGET}-intr.o"
        COMMAND "${CMAKE_RTEMS_SYMS}" -e -C "${CMAKE_C_COMPILER}" -c "${CMAKE_C_FLAGS}" -o "${TARGET}-intr.o" "${TARGET}"
        DEPENDS "${CMAKE_BINARY_DIR}/${TARGET}"
        COMMENT "Generating list of embedded symbols"
    )

    # Generate a stage 2 exe with embedded symbol table
    add_executable(
        ${TARGET}.exe $<TARGET_OBJECTS:${TARGET}> "${CMAKE_BINARY_DIR}/${TARGET}-intr.o"
    )

    # Link against the same libraries as stage 1 executable
    target_link_libraries(
        ${TARGET}.exe $<TARGET_PROPERTY:${TARGET},LINK_LIBRARIES>
    )

    set_target_properties(
        ${TARGET}.exe PROPERTIES LINKER_LANGUAGE C
    )

    # Generate a flat binary file that can be directly booted
    add_custom_command(
        OUTPUT "${CMAKE_BINARY_DIR}/${TARGET}.boot"
        COMMAND "${CMAKE_OBJCOPY}" -O binary "${TARGET}.exe" "${TARGET}.boot"
        DEPENDS "${CMAKE_BINARY_DIR}/${TARGET}.exe"
        COMMENT "Generating bootable image ${TARGET}.boot"
    )

    add_custom_target(
        "${TARGET}-boot" ALL
        DEPENDS "${CMAKE_BINARY_DIR}/${TARGET}.boot"
    )
    
    # Install to an EPICS-style "shared" prefix
    if (SHARED_PREFIX)
        install(
            TARGETS "${TARGET}"
            
            RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}/RTEMS-${RTEMS_BSP}"
            LIBRARY DESTINATION "${CMAKE_INSTALL_LIBDIR}/RTEMS-${RTEMS_BSP}"
            ARCHIVE DESTINATION "${CMAKE_INSTALL_LIBDIR}/RTEMS-${RTEMS_BSP}"
        )
        install(
            FILES "${CMAKE_BINARY_DIR}/${TARGET}.boot" "${CMAKE_BINARY_DIR}/${TARGET}.obj" "${CMAKE_BINARY_DIR}/${TARGET}.exe"
            DESTINATION "${CMAKE_INSTALL_BINDIR}/RTEMS-${RTEMS_BSP}"
        )
    else()
        install(
            FILES "${CMAKE_BINARY_DIR}/${TARGET}.boot" "${CMAKE_BINARY_DIR}/${TARGET}.obj" "${CMAKE_BINARY_DIR}/${TARGET}.exe"
            DESTINATION "${CMAKE_INSTALL_BINDIR}"
        )
    endif()
endfunction()

# Helper function to add and generate a rootfs.
# This will automatically add the rootfs.c file to your target. call rootfs_unpack() to unpack at runtime
function(rtems_add_rootfs TARGET DIR)
    # Generate list of files we'll depend on
    file(GLOB_RECURSE ROOTFS_FILES "${DIR}/**")

    add_custom_command(
        OUTPUT "${CMAKE_BINARY_DIR}/${TARGET}-rootfs.c"
        COMMAND "${CMAKE_CURRENT_FUNCTION_LIST_DIR}/../mkrootfs.py" -o "${CMAKE_BINARY_DIR}/${TARGET}-rootfs.c" -i "${DIR}"
        DEPENDS ${ROOTFS_FILES}
    )
    
    # Add rootfs sources to target
    target_sources(
        ${TARGET} PRIVATE "${CMAKE_BINARY_DIR}/${TARGET}-rootfs.c"
    )
endfunction()
