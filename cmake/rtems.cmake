# Additional tools for RTEMS

# A quick rundown on what's happening here:
#
#  ${TARGET}
#    First, ${TARGET} is generated. This is a standard ELF executable linked with the relevant RTEMS
#    flags. This is the "stage 1" binary.
# 
#  ${TARGET}.obj
#    Next, a loadable symbols object is generated off of ${TARGET}. This is meant to be used with the
#    RTEMS dynamic linker, as it needs an ELF file without program headers or anything like that.
#
#  ${TARGET}-intr.o
#    An object file generated by rtems-syms that includes the embedded symbol table. Linked into stage 2
#
#  ${TARGET}.exe
#    The "stage 2" binary. This uses the same link command as the stage 1 binary, except that it also
#    includes ${TARGET}-intr.o and the accompanying embedded symbol table. The runtime linker (RTL) will
#    use the embedded symbol table to resolve symbols in object files loaded later on.
#
#  ${TARGET}.boot
#    This is the actual bootable image. It's just a flat binary generated off of the stage 2 .exe 
# 
# NOTE: The above is only relevant for RTEMS 6. RTEMS 4.X w/cexpsh and GeSys behaves similarly,
#  but uses different tools to accomplish the task. Those tools are not supported here.


include(GNUInstallDirs)

# Helper command to add an ELF executable and generate a bootable image from it
function(rtems_add_executable TARGET)

    # Generate base executable that will be used to feed rtems-syms
    add_executable(
        ${TARGET} ${ARGN}
    )

    # Generate a loadable symbols object
    add_custom_command(
        OUTPUT "${CMAKE_BINARY_DIR}/${TARGET}.obj"
        COMMAND "${CMAKE_RTEMS_SYMS}" -C "${CMAKE_C_COMPILER}" -c "${CMAKE_C_FLAGS}" -o "${TARGET}.obj" "${CMAKE_BINARY_DIR}/${TARGET}"
        DEPENDS "${TARGET}"
        COMMENT "Generating loadable symbols"
    )

    # Gather symbols off of the executable
    add_custom_command(
        OUTPUT "${CMAKE_BINARY_DIR}/${TARGET}-intr.o"
        COMMAND "${CMAKE_RTEMS_SYMS}" -e -C "${CMAKE_C_COMPILER}" -c "${CMAKE_C_FLAGS}"
            -m "${CMAKE_BINARY_DIR}/${TARGET}.map" -o "${CMAKE_BINARY_DIR}/${TARGET}-intr.o" "${CMAKE_BINARY_DIR}/${TARGET}"
        DEPENDS "${TARGET}"
        COMMENT "Generating list of embedded symbols"
    )

    # Generate a stage 2 exe with embedded symbol table
    add_executable(
        ${TARGET}-exe $<TARGET_OBJECTS:${TARGET}> "${CMAKE_BINARY_DIR}/${TARGET}-intr.o"
    )

    # Link against the same libraries as stage 1 executable
    target_link_libraries(
        ${TARGET}-exe $<TARGET_PROPERTY:${TARGET},LINK_LIBRARIES>
    )

    set_target_properties(
        ${TARGET}-exe PROPERTIES
            LINKER_LANGUAGE C
            OUTPUT_NAME ${TARGET}.exe
    )

    # Generate a flat binary file that can be directly booted
    add_custom_command(
        OUTPUT "${CMAKE_BINARY_DIR}/${TARGET}.boot"
        COMMAND "${CMAKE_OBJCOPY}" -O binary "${TARGET}.exe" "${TARGET}.boot"
        DEPENDS "${TARGET}-exe"
        COMMENT "Generating bootable image ${TARGET}.boot"
    )

    add_custom_target(
        "${TARGET}-boot" ALL
        DEPENDS "${CMAKE_BINARY_DIR}/${TARGET}.boot"
    )
    
    # Install to an EPICS-style "shared" prefix
    if (SHARED_PREFIX)
        install(
            TARGETS "${TARGET}"
            
            RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}/RTEMS-${RTEMS_BSP}"
            LIBRARY DESTINATION "${CMAKE_INSTALL_LIBDIR}/RTEMS-${RTEMS_BSP}"
            ARCHIVE DESTINATION "${CMAKE_INSTALL_LIBDIR}/RTEMS-${RTEMS_BSP}"
        )
        install(
            FILES "${CMAKE_BINARY_DIR}/${TARGET}.boot" "${CMAKE_BINARY_DIR}/${TARGET}.obj" "${CMAKE_BINARY_DIR}/${TARGET}.exe"
            DESTINATION "${CMAKE_INSTALL_BINDIR}/RTEMS-${RTEMS_BSP}"
        )
    else()
        install(
            FILES "${CMAKE_BINARY_DIR}/${TARGET}.boot" "${CMAKE_BINARY_DIR}/${TARGET}.obj" "${CMAKE_BINARY_DIR}/${TARGET}.exe"
            DESTINATION "${CMAKE_INSTALL_BINDIR}"
        )
    endif()
endfunction()

# Helper function to add and generate a rootfs.
# This will automatically add the rootfs.c file to your target. call rootfs_unpack() to unpack at runtime
function(rtems_add_rootfs TARGET DIR TYPE)
    # Generate list of files we'll depend on
    file(GLOB_RECURSE ROOTFS_FILES "${DIR}/**")

    set(ROOTFS_ARGS "")
    if ("${TYPE}" STREQUAL "tar" OR "${TYPE}" STREQUAL "TAR")
        set(ROOTFS_ARGS "-t")
    endif()

    add_custom_command(
        OUTPUT "${CMAKE_BINARY_DIR}/${TARGET}-rootfs.c"
        COMMAND "${CMAKE_CURRENT_FUNCTION_LIST_DIR}/../mkrootfs.py" "${ROOTFS_ARGS}"
            -o "${CMAKE_BINARY_DIR}/${TARGET}-rootfs.c" -i "${DIR}"
            -m "BSP_LIBS=${RTEMS_TOP}/target/rtems/${RTEMS_ARCH}-rtems${RTEMS_TOOL_VERSION}/${RTEMS_BSP}/lib"
            -m "TOOLCHAIN_LIBS=${RTEMS_TOP}/host/linux-x86_64/${RTEMS_ARCH}-rtems${RTEMS_TOOL_VERSION}/lib"
        DEPENDS ${ROOTFS_FILES}
    )
    
    # Add rootfs sources to target
    target_sources(
        ${TARGET} PRIVATE "${CMAKE_BINARY_DIR}/${TARGET}-rootfs.c"
    )
endfunction()
